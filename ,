from tornado.tcpserver import TCPServer
from tornado.iostream import StreamClosedError
from tornado import gen
import tornado.ioloop
from packet import PacketManager, PacketBuilder
from constants import OpCode
from helper import Vector3
import attr
import random


@attr.s
class Client:
    stream = attr.ib(repr=False)
    address = attr.ib(repr=False)
    authenticated = attr.ib(default=False)
    _id = attr.ib(default=0)
    username = attr.ib(default="")
    player_position = attr.ib(default=Vector3(0.0, 0.0, 0.0))
    disconnected = attr.ib(default=False)

    async def start_coro(self, clients):
        while True:
            try:
                data = await self.stream.read_until(b"\xAA\x99")
                try:
                    pm = PacketManager(data)
                    if pm.opcode == OpCode.Authentication:
                        is_exists = clients.check_username_exists(pm.username)
                        if is_exists:
                            # TODO: return error
                            return
                        else:
                            self._id = random.randint(0, 499)
                            self.username = pm.username
                            self.authenticated = True
                    elif pm.opcode == OpCode.PlayerMovement:
                        self.player_position = pm.player_position
                        packet = PacketBuilder.build(
                            OpCode.PlayerMovement,
                            {
                                "id": self._id,
                                "X": self.player_position.X,
                                "Y": self.player_position.Y,
                                "Z": self.player_position.Z,
                            },
                        )

                        await clients.broadcast_movement(self, packet)

                    print("client", self)
                except Exception as e:
                    print(f"error while parsing data {str(e)} - data {data}")
                # else:
                #     print("data", data)
            except StreamClosedError:
                self.disconnected = True
                clients.delete_player(self)
                break


@attr.s
class Clients:
    _players: list = attr.ib(default=[])

    def get_player_count(self):
        return len(self._players)

    def add_new_player(self, client: Client):
        self._players.append(client)

    def delete_player(self, client: Client):
        self._players.remove(client)

    def check_username_exists(self, username: str) -> bool:
        for player in self._players:
            if player.username == username:
                return True
        return False

    async def broadcast_movement(self, client, packet):
        for player in self._players:
            if player != client:
                print(f"packet sent to user {player.username}")
                await player.stream.write(packet)
        return

    async def broadcast_msg(self, msg):
        print(f"Sending {msg} to all clients {len(self.conns)}")
        for conn in self.conns:
            await conn.write(msg.encode("utf-8"))


clients_ref = Clients()


class EchoServer(TCPServer):
    conns = []

    async def handle_stream(self, stream, address):
        print(f"Client connected {address}")
        client = Client(stream, address)
        clients_ref.add_new_player(client)
        await client.start_coro(clients_ref)


if __name__ == "__main__":
    server = EchoServer()
    server.listen(8888)
    tornado.ioloop.IOLoop.current().start()

"""
data_str = data.decode("utf-8")
if data_str.startswith("broadcast"):
    msg = data_str.split("broadcast ")[1]
    opcode = msg.split('-')[0]
    custom_msg = "USER_SPAWN"
    if opcode == "USER_SPAWN":
        custom_msg = "USER_SPAWN"
        # rest = msg.split('-')[1]
        # Z, Y, X = rest.split("|")
        # X = r
        X = 1.720723
        Y = 0.9399997
        Z = 5
        D = -1
    print("woop ", opcode)
    await self.broadcast_msg(custom_msg)
else:
    await stream.write(data)
"""
